# 质押收益

- 质押收益介绍
- Defi质押的操作流程
- 合约实现

## 质押收益介绍

**Defi：单币质押、流动性质押、借贷等**

**PoS质押：以太坊通过质押ETH来选择验证人，参与新的区块产生的验证**

**其它：GameFi、NFT质押**

### **常见Defi质押介绍**

### **单币质押：**

**平台：AAVE、Compound、LaunchPad（Staking）**

**原理：用户存入一种代币，获取利息或质押收益**

**举例：相当于去中心化银行存款，在LaunchPad中存入C2N代币，获取C2N代币奖励**

### **流动性质押：**

**平台：Uniswap、PancakeSwap**

**原理：用户提供两种代币组成的交易对，换取流动性代币**

**举例：在Uniswap中提供交易币对，获取交易币对的LP Token，通过LP token获得奖励或参与其它活动**

### **借贷质押：**

**平台：AAVE、Compound**

**原理：用户存入抵押资产，借出另一种资产，同时获取利息或治理代币利息**

**举例：在AAVE中存入ETH赚取利息，同时获取AAVE代币奖励**

## **质押机制和流程**

1. **两种IERC20：质押代币、奖励代币（可以是同种代币）**
2. **奖励机制设置**
3. 用户质押代币

## 合约实现**（理解**变量含义、安全性**）**

- [x]  合约变量
- [x]  构造函数（质押代币、奖励代币、管理员）
- [x]  管理员modifier
- [x]  设置持续时间、设置奖励速率（notifyRewardAmount）
- [x]  **更新收益modifier**
- [x]  ##### 质押、撤回、**获取收益函数**
- [x]  状态查询函数

### 设置奖励金额和分配速率

```solidity
function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {
    if (block.timestamp > finishAt) {
        rewardRate = _amount / duration;
    } else {
        uint256 remainingRewards = rewardRate * (finishAt - block.timestamp);
        rewardRate = (remainingRewards + _amount) / duration;
    }
    require(rewardRate > 0, "reward rate = 0");
    require(rewardRate * duration <= rewardsToken.balanceOf(address(this)), "reward amount > balance");
    finishAt = block.timestamp + duration;
    updatedAt = block.timestamp;
}
```

- 当当前时间超过上一个奖励周期结束时间(`finishAt`)时，创建一个全新的奖励周期
- 当当前时间还在上一个奖励周期内时，将剩余奖励与新奖励合并计算新的分配速率
- 更新奖励结束时间(`finishAt`)为当前时间加上持续时间(`duration`)

1. 当前时间：1600，finishAt：1500，amount：1000，duration：1000
    1. rewardRate：1
2. 当前时间：2000，finishAt：2600，amount：1000，duration：1000
    1. remainingRewards：600
    2. rewardRate：1.6

### 在关键操作前更新用户奖励状态

```solidity
modifier updateReward(address _account) {
    rewardPerTokenStored = rewardPerToken();
    updatedAt = lastTimeRewardApplicable();

    if (_account != address(0)) {
        rewards[_account] = earned(_account);
        userRewardPerTokenPaid[_account] = rewardPerTokenStored;
    }
    _;
}
```

```solidity
function rewardPerToken() public view returns (uint256) {
    if (totalSupply == 0) return rewardPerTokenStored;
    return rewardPerTokenStored + (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalSupply;
}
```

```solidity
function lastTimeRewardApplicable() public view returns (uint256) {
      return _min(block.timestamp, finishAt);
}
```

时间轴：
t0 ---- t1 (用户A质押) ---- t2 (用户B质押) ---- t3 (现在) —— t4(用户A质押)

全局 rewardPerTokenStored 发展：
t0: 0
t1: 1.2
t2: 1.8
t3: 2.5

t4: 2.8

用户A：

- 质押时(t1) userRewardPerTokenPaid[A] = 1.2
- earned[A] = 质押金额 × (2.5 - 1.2) + rewards[A]

用户B：

- 质押时(t2) userRewardPerTokenPaid[B] = 1.8
- earned[B] = 质押金额 × (2.5 - 1.8) + rewards[B]

### 计算用户当前可领取的奖励总额

```solidity
function earned(address _account) public view returns (uint256) {
    return (balanceOf[_account] * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18 + rewards[_account];
}
```

质押时，会按照当前用户的质押数量，先以当前质押的数额，将奖励存入用户的rewards中去，然后重置用户的奖励计算参数（因为质押的总金额变了，每个质押代币对应的奖励数额也变了）

每次的质押、撤回，都会重新计算用户的rewards[account]

## 课程代码

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/interfaces/IERC20.sol";

contract StakingRewards {
    IERC20 public immutable stakingToken;//用户用来质押的代币合约地址。
    IERC20 public immutable rewardsToken;//作为奖励分发给质押者的代币合约地址
    address public owner;//合约的管理员地址。只有 owner 才能设置奖励周期和添加奖励。
    uint256 public duration;//奖励分发的持续时间（以秒为单位）
    uint256 public finishAt;//当前奖励周期的结束时间戳。当 block.timestamp 超过这个值时，奖励就停止分发了。
    uint256 public updatedAt;//上一次更新奖励状态的时间戳。它记录了 rewardPerTokenStored 最后一次被计算的时间。
    uint256 public rewardRate;
    //奖励分发速率，单位是 rewardsToken 的最小单位 / 每秒。例如，如果 rewardRate 是 1e18，就表示每秒分发 1 个 rewardsToken (假设 rewardsToken 是18位小数)。
    uint256 public rewardPerTokenStored;
    //核心变量。这是一个累积值，代表从合约开始到 updatedAt 时间点为止，每一个质押单位（1 stakingToken 的最小单位）总共能分到多少奖励。为了处理小数精度，这个值被放大了 1e18 倍。

    mapping(address => uint256) public userRewardPerTokenPaid;
    //记录每个用户上一次与合约交互时，当时的 rewardPerTokenStored 是多少。通过用当前最新的 rewardPerToken() 减去这个值，就能知道该用户自上次操作以来，每个质押单位新获得了多少奖励。
    mapping(address => uint256) public rewards;
//记录每个用户已计算但尚未领取的奖励总额。当用户执行 stake, withdraw 或 getReward 时，新产生的奖励会被计算出来并累加到这个映射中。
    uint256 public totalSupply;//当前合约中质押的 stakingToken 总量。
    mapping(address => uint256) public balanceOf;//记录每个用户质押了多少 stakingToken。


	
    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }
	
    modifier updateReward(address _account) {
        rewardPerTokenStored = rewardPerToken();
        updatedAt = lastTimeRewardApplicable();

        if (_account != address(0)) {
            rewards[_account] = earned(_account);
            userRewardPerTokenPaid[_account] = rewardPerTokenStored;
        }

        _;
    }
	//updateReward(address _account)
//合约的引擎。在任何改变用户质押状态或用户领取奖励的操作之前，它都会被触发。

//rewardPerTokenStored = rewardPerToken(): 将动态计算的最新“每单位总奖励”固化下来，存入 rewardPerTokenStored。
//updatedAt = lastTimeRewardApplicable(): 更新时间戳，标记固化的时间点。
//如果传入的 _account 不是零地址（即针对特定用户），则：
//* rewards[_account] = earned(_account): 计算该用户所有应得的奖励，并存入其 rewards "桶"中。
//* userRewardPerTokenPaid[_account] = rewardPerTokenStored: 将该用户“已支付”的记录更新到最新的“每单位总奖励”值，为下一次计算做准备。
    constructor(address _stakingToken, address _rewardsToken) {
    //合约部署时执行，初始化质押代币、奖励代币和合约所有者。
        owner = msg.sender;
        stakingToken = IERC20(_stakingToken);
        rewardsToken = IERC20(_rewardsToken);
    }

    function setRewardsDuration(uint256 _duration) external onlyOwner {
    //owner 调用，用于设置奖励分发的周期 duration。要求必须在当前奖励周期结束后才能设置新的周期。
        require(finishAt < block.timestamp, "reward duration not finished");
        duration = _duration;
    }

    function notifyRewardAmount(uint256 _amount)
        external
        onlyOwner
        updateReward(address(0))
    {
    
    //核心管理员函数。owner 调用此函数来“注入”或“补充”奖励。

//它首先调用 updateReward(address(0)) 来更新全局的奖励累积值，确保计算的起点是准确的。
//如果上一个奖励周期已结束，它会根据新的 _amount 和 duration 计算出新的 rewardRate。
//如果上一个周期未结束，它会把新注入的 _amount 和剩余的奖励加在一起，然后除以 duration，重新计算 rewardRate（相当于“加码”）。
//它会检查 rewardRate 是否大于0，以及合约拥有的 rewardsToken 余额是否足够按此速率分发完整个周期。
//最后，更新 finishAt 和 updatedAt 时间戳，正式开启或延续奖励分发。
        if (block.timestamp > finishAt) {
            rewardRate = _amount / duration;
        } else {
            uint256 remainingRewards = rewardRate *
                (finishAt - block.timestamp);
            rewardRate = (remainingRewards + _amount) / duration;
        }
        require(rewardRate > 0, "reward rate = 0");
        require(
            rewardRate * duration <= rewardsToken.balanceOf(address(this)),
            "reward amount > balance"
        );
        finishAt = block.timestamp + duration;
        updatedAt = block.timestamp;
    }

    function stake(uint256 _amount) external updateReward(msg.sender) {
   // 用户质押代币。
//updateReward(msg.sender) 修饰符会先运行：计算并累积该用户到目前为止应得的奖励。
//然后，合约从用户地址转入 _amount 数量的 stakingToken。
//最后，增加用户的 balanceOf 和合约的 totalSupply。
        require(_amount > 0, "amount = 0");
        stakingToken.transferFrom(msg.sender, address(this), _amount);
        balanceOf[msg.sender] += _amount;
        totalSupply += _amount;
    }

    function withdraw(uint256 _amount) external updateReward(msg.sender) {
    //用户取回质押的代币。
//updateReward(msg.sender) 修饰符同样先运行，结算奖励。
//减少用户的 balanceOf 和合约的 totalSupply。
//最后，将 _amount 数量的 stakingToken 转回给用户。
        require(_amount > 0, "amount = 0");
        balanceOf[msg.sender] -= _amount;
        totalSupply -= _amount;
        stakingToken.transfer(msg.sender, _amount);
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
    //一个辅助视图函数，返回当前区块时间戳 block.timestamp 和奖励结束时间 finishAt 中的较小者。这确保奖励计算不会超出设定的结束时间。
        return _min(block.timestamp, finishAt);
    }

    function rewardPerToken() public view returns (uint256) {
    //核心计算函数。它动态计算出截至当前时刻，每单位质押代币应得的总奖励。
//公式: 累积奖励 + 新增奖励
//rewardPerTokenStored + ((rewardRate * (lastTimeRewardApplicable() - updatedAt)) * 1e18) / totalSupply
//它计算了从上次更新 (updatedAt) 到现在 (lastTimeRewardApplicable()) 这段时间内新产生的奖励，并将其按比例分配到每一单位的质押代币上，然后加到旧的累积值上。
        if (totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            ((rewardRate * (lastTimeRewardApplicable() - updatedAt)) * 1e18) /
            totalSupply;
    }

    function earned(address _account) public view returns (uint256) {
   // 计算指定账户当前总共可以领取的奖励数量。
//公式: (用户质押量 * (当前每单位总奖励 - 用户上次记录的每单位总奖励)) + 用户已结算但未领取的奖励
//(balanceOf[_account] * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18 + rewards[_account]
//这正是此模式的精髓：它只关心全局的变化量和用户自己的状态，而无需关心其他用户。


        return
            (balanceOf[_account] *
                (rewardPerToken() - userRewardPerTokenPaid[_account])) /
            1e18 +
            rewards[_account];
    }

    function getReward() external updateReward(msg.sender) {
    //用户领取奖励。
//updateReward(msg.sender) 修饰符先运行，将所有应得奖励结算到 rewards[msg.sender] 中。
//函数主体检查 rewards[msg.sender] 是否大于0。
//如果是，将这部分奖励 rewardsToken 转给用户，并将 rewards[msg.sender] 清零。
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.transfer(msg.sender, reward);
        }
    }

    function _min(uint256 x, uint256 y) private pure returns (uint256) {
        return x <= y ? x : y;
    }
}

```

###  核心机制与流程

这个合约的质押机制可以比作一个**“里程碑”系统**。

**核心思想**:
合约维护一个全局的“里程碑”——`rewardPerTokenStored`，它代表每单位质押物累计可以获得多少奖励。这个里程碑只会向前推进。当一个用户与合约交互时，合约会记录下他当前所在的“里程碑位置” (`userRewardPerTokenPaid`)。用户的奖励就是他持有的质押量，乘以他上次记录的里程碑与当前最新里程碑之间的“距离”。

**流程示例**:

1. **管理员启动奖励**:

   - 管理员调用 `setRewardsDuration(604800)` 设置为期 7 天。
   - 管理员向合约转入 `7000` 个 `rewardsToken`。
   - 管理员调用 `notifyRewardAmount(7000 * 1e18)`。
   - 合约计算出 `rewardRate` = `7000 / 604800` ≈ `0.01157` 个币/秒。`finishAt` 被设定为 `now + 7 days`。奖励开始分发。

2. **Alice 质押**:

   - Alice 调用 `stake(100 * 1e18)`。
   - `updateReward` 运行。此时 Alice 没质押过，所以 `earned` 是 0。`userRewardPerTokenPaid[Alice]` 被更新为当前的 `rewardPerTokenStored` (假设为 `R1`)。
   - Alice 的 `balanceOf` 变为 100。

3. **时间流逝 (例如1天)**:

   - `rewardPerToken()` 的值在不断增长，因为时间在走，奖励在累积。

4. **Bob 质押**:

   - Bob 调用 `stake(300 * 1e18)`。
   - `updateReward` 运行。Bob 也没质押过，`earned` 是 0。`userRewardPerTokenPaid[Bob]` 被更新为当前的 `rewardPerTokenStored` (假设为 `R2`，`R2 > R1`)。
   - Bob 的 `balanceOf` 变为 300。`totalSupply` 变为 400。

5. **Alice 领取奖励**:

   - 又过了1天，Alice 调用 `getReward()`。

   - ```
     updateReward(Alice)
     ```

      

     运行：

     - 合约计算出此刻最新的 `rewardPerToken()` 值 (假设为 `R3`)。
     - Alice 的新奖励 = `Alice的质押量 * (R3 - R1)`。
     - 这笔奖励被存入 `rewards[Alice]`。
     - `userRewardPerTokenPaid[Alice]` 被更新为 `R3`。

   - `getReward` 函数体将 `rewards[Alice]` 中的代币转给 Alice，并将其清零。

这个设计极其高效，无论有多少人质押，每次操作的 Gas 成本都是恒定的，因为它从不迭代用户列表。