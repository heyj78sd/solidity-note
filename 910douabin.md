```
问：dex的业务，你觉得最难的一点是什么
答：旧系统迁移，k线图，csrsl迁移上
问：团队有多少人，扮演什么角色
答在团队需要负责前端管理，系统架构，前端工程化
问：详细介绍前端工程化
答国际化业务，不是单点，服务端部署是多地区的，多语言多域名，前端模块，表单交易模块跟别的分开，在运维方面配合工作，对前端的稳定进行监控以及一些稳定性的工作，埋点工作
问打包这一块也是你做的吗？
答比如多语言的配置，把语言文件给一些服务商存储，然后前端csr加载多语言，打包的话，比如有一些资源要提前上传的
问刚刚你提到性能的部分，假设一个场景，假如一个页面出现内存泄露，怎么排查，尽量缩小范围
答先去看埋点报告，然后看页面是不是白屏了，看一看实际的超高情况，然后去看那个瀑布，如果发现一个文件执行很久，就去定位这个文件，然后找到这个变量再去本地复现，review代码，然后不可能一直泄露，所以可以基于上一个版本没问题的情况下去review
问好现在给你一个场景，要设计一个组件，通用性比较广泛，，比如交易所界面要设计一个dialog对话框，你会考虑到设计什么东西提供给外部
答接下来手写一个代码，这是一个很多的异步请求，需要你封装一个promise函数，传一个数组里面是一个很多的异步请求，同时请求，不能用await ，然后请求之后允许两个以下出现错误，超过就视为是失败，只需要返回成功结果，数组长度10
```

### 一、整理出的具体问题

1. **DEX业务中最难的一点是什么？**  
2. **团队有多少人？各自扮演什么角色？你在团队中负责什么？**  
3. **请详细介绍前端工程化（根据回答进一步追问）**  
4. **打包这一块也是你负责的吗？**  
5. **假设一个页面出现内存泄漏，如何排查并尽量缩小范围？**  
6. **设计一个通用性较强的Dialog组件，需要考虑哪些设计要素？**  
7. **手写代码：封装一个Promise函数，传入一个包含10个异步请求的数组，要求同时发起请求，允许最多2个失败，最终返回所有成功的结果（若失败数超过2则整体视为失败）。**

---

### 二、原回答整理（根据笔记还原）

1. **DEX业务难点**：  
   - 旧系统迁移  
   - K线图实现  
   - CSR（Client-Side Rendering）迁移至SSR（Server-Side Rendering）或其它架构  

2. **团队角色与个人职责**：  
   - 未明确提及团队人数  
   - 个人负责前端管理、系统架构、前端工程化  

3. **前端工程化**：  
   - 国际化业务（多地区部署、多语言、多域名）  
   - 前端模块化（如表单交易模块独立）  
   - 运维配合（稳定性监控、埋点）  

4. **打包相关工作**：  
   - 多语言配置（语言文件由服务商存储，前端CSR加载）  
   - 资源提前上传  

5. **内存泄漏排查**：  
   - 先看埋点报告，确认页面是否白屏或性能异常  
   - 通过瀑布流分析文件加载与执行时间  
   - 定位问题文件并Review代码  
   - 基于上一个稳定版本对比排查  

6. **Dialog组件设计**：  
   - 未提供具体回答（需手写代码，但问题本身是设计思路）  

7. **手写代码题**：  
   - 未提供代码（需实现Promise封装）  

---

### 三、根据问题整理的推荐答案（专业版）

- ### 一、问题与详细答案

  #### 1. **DEX业务中最难的一点是什么？**  
  **答案**：  
  DEX（去中心化交易所）业务中最具挑战性的部分包括：  
  - **旧系统迁移**：需要兼容历史数据、业务逻辑和用户状态，确保迁移过程中数据一致性和用户体验无缝过渡。  
  - **K线图实现**：要求高性能实时渲染（通常使用WebGL或Canvas优化）、数据处理（实时行情推送、缓存策略）和交互复杂性（缩放、拖拽、指标计算）。  
  - **CSR迁移至SSR/混合架构**：为了解决SEO和首屏加载速度问题，但需解决状态同步、服务端渲染hydration问题以及部署复杂度（如多地区部署）。  

  ---

  #### 2. **团队有多少人？各自扮演什么角色？你在团队中负责什么？**  
  **答案**：  
  - 典型DEX团队规模为**5-10人**（含前端、后端、产品、运维）。  
  - 角色分工：  
    - **前端**：3-4人（负责交易界面、资产管理、K线模块等）。  
    - **后端**：2-3人（API设计、区块链节点交互、数据同步）。  
    - **产品/设计**：1-2人（需求规划、用户体验设计）。  
    - **运维/测试**：1人（部署、监控、自动化测试）。  
  - **个人职责**：  
    - 前端技术选型与架构设计（如React/Vue+TypeScript）。  
    - 前端工程化（构建、部署、性能优化）。  
    - 跨团队协作（与后端定义API规范、与运维设计CDN/灰度发布）。  

  ---

  #### 3. **请详细介绍前端工程化**  
  **答案**：  
  前端工程化涵盖以下核心领域：  
  - **国际化（i18n）**：  
    - 动态多语言加载（语言文件托管CDN，按需加载）。  
    - 多地区域名路由（如`en.domain.com`、`cn.domain.com`）。  
  - **模块化与组件化**：  
    - 业务模块拆分（交易、资产、K线独立打包，避免单体应用）。  
    - 通用组件库（Button、Dialog、Chart）抽象与复用。  
  - **构建与部署**：  
    - **CI/CD流水线**（GitLab CI/Jenkins）：自动构建、测试、部署到多环境。  
    - **静态资源优化**：哈希文件名、CDN上传、Tree Shaking减少体积。  
  - **监控与稳定性**：  
    - 性能埋点（FP/FCP、内存泄漏监控）。  
    - 错误追踪（Sentry日志收集、告警机制）。  
  - **开发效率**：  
    - 脚手架工具（快速初始化项目）。  
    - 代码规范（ESLint/Prettier+Husky预提交检查）。  

  ---

  #### 4. **打包这一块也是你负责的吗？**  
  **答案**：  
  是的，打包相关工作包括：  
  - **构建配置**：使用Webpack/Vite进行多环境构建（开发/生产/测试）。  
  - **多语言处理**：  
    - 语言文件通过CI脚本自动上传至CDN，构建时注入版本号。  
    - 运行时动态加载语言包（避免打包进主Bundle）。  
  - **资源优化**：  
    - 代码分割（Code Splitting）按路由懒加载。  
    - 图片压缩、SVG雪碧图、字体子集化。  

  ---

  #### 5. **内存泄漏排查方法**  
  **答案**：  
  **步骤**：  
  1. **现象确认**：  
     - 通过监控系统（如Sentry）或用户反馈发现页面卡顿/白屏。  
     - Chrome DevTools的Performance面板录制内存变化（观察JS Heap是否持续增长）。  
  2. **定位问题**：  
     - 使用Memory面板拍摄Heap Snapshot，对比操作前后的对象分配。  
     - 查看Retainers链（找到未被释放的引用源）。  
  3. **常见场景**：  
     - 全局事件监听（`window.addEventListener`未移除）。  
     - 定时器（`setInterval`未清除）。  
     - 闭包引用（例如函数内引用外部变量导致无法回收）。  
     - 第三方库（如Chart.js、ECharts需手动调用`dispose()`）。  
  4. **修复验证**：  
     - 注释代码块逐步排查，复现后修复（如组件卸载时销毁监听）。  
     - 使用Chrome DevTools的Memory面板验证修复后内存是否稳定。  

  ---

  #### 6. **通用Dialog组件设计**  
  **答案**：  
  **设计要素**：  
  - **Props API**：  
    ```ts
    interface DialogProps {
      visible: boolean;
      title?: string | ReactNode;
      onClose: () => void;
      footer?: ReactNode | null; // 自定义底部按钮
      closeOnEsc?: boolean; // 按ESC关闭
      closeOnMaskClick?: boolean; // 点击遮罩关闭
    }
    ```
  - **插槽机制**：  
    - 支持`header`、`body`、`footer`插槽（如`<Dialog.Header>{...}</Dialog.Header>`）。  
  - **动画与体验**：  
    - 淡入淡出动画（CSS Transition或React Spring）。  
    - 焦点管理（打开时聚焦到Dialog内，关闭后返回原焦点）。  
  - **无障碍（A11y）**：  
    - 添加`role="dialog"`、`aria-labelledby`标注。  
    - 键盘导航（ESC关闭、Tab限制在Dialog内循环）。  
  - **样式方案**：  
    - CSS-in-JS（如Styled-components）或Scoped CSS（Vue的`<style scoped>`）。  
    - 通过Context提供主题配置（如尺寸、颜色）。  

  ---

  #### 7. **手写代码：并发请求控制**  
  **答案**：  
  ```javascript
  function concurrentRequests(requests, maxFailures = 2) {
    return Promise.allSettled(requests.map(req => typeof req === 'function' ? req() : req))
      .then(results => {
        const failures = results.filter(r => r.status === 'rejected');
        if (failures.length > maxFailures) {
          throw new Error(`Failures exceeded limit (${failures.length} > ${maxFailures})`);
        }
        return results
          .filter(r => r.status === 'fulfilled')
          .map(r => r.value);
      });
  }
  
  // 使用示例
  const requests = [
    () => fetch('/api/1'),
    () => fetch('/api/2'),
    // ...共10个请求
  ];
  concurrentRequests(requests, 2)
    .then(console.log)
    .catch(console.error);
  ```
  **关键点**：  
  - 使用`Promise.allSettled`等待所有请求完成（无论成功失败）。  
  - 过滤失败结果，若失败数超过阈值则抛出错误。  
  - 返回成功结果的数组（仅包含`fulfilled`的值）。  

  ---

  ### 总结  
  - 答案需体现**技术深度**（如工程化全链路、内存泄漏工具使用）和**系统思维**（从设计到监控）。  
  - 手写代码注意边界情况（例如请求非函数、错误处理）。  
  - 设计题强调**扩展性**（插槽、配置化）和**用户体验**（动画、无障碍）。