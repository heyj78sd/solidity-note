### ERC721 学习笔记

ERC721 是以太坊上的一个智能合约标准（EIP-721），用于实现非同质化代币（Non-Fungible Tokens，简称 NFTs）。与其他代币标准如 ERC20（可互换代币）不同，ERC721 的代币每个都是唯一的，不可互换，常用于数字艺术、收藏品、游戏资产等领域。ERC721 定义了一个接口（IERC721），合约必须实现这个接口才能兼容。OpenZeppelin 等库提供了标准实现。

代码地址：https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol

本笔记基于 ERC721 的核心接口和典型实现（如 OpenZeppelin 的 ERC721.sol）。我会先解释核心变量，然后逐一解释函数，最后说明运行机制。笔记使用结构化格式，便于学习。

#### 1. 核心变量（内部状态）
ERC721 合约维护几个关键的映射（mapping）和计数器，用于跟踪代币的所有权、批准和余额。这些变量通常是私有的（private），只能通过函数访问，以确保安全。

- **_owners**：类型 `mapping(uint256 => address)`  
  这是一个从代币 ID（tokenId，通常是 uint256）到所有者地址的映射。  
  解释：存储每个 NFT 的当前所有者。如果一个 tokenId 不存在或已被销毁，则映射值为 address(0)（零地址）。这是合约的核心状态，用于查询 ownerOf 函数。

- **_balances**：类型 `mapping(address => uint256)`  
  这是一个从地址到该地址拥有的 NFT 数量的映射。  
  解释：跟踪每个地址的 NFT 余额。不同于 ERC20 的小数余额，这里是整数计数（因为 NFT 是离散的）。当转移 NFT 时，会更新发送者和接收者的余额。

- **_tokenApprovals**：类型 `mapping(uint256 => address)`  
  这是一个从 tokenId 到批准地址的映射。  
  解释：存储单个 NFT 的批准操作者（operator）。如果一个 NFT 被批准给某个地址，则该地址可以转移这个 NFT，而无需是所有者。批准后，通过 transferFrom 或 safeTransferFrom 函数执行转移。

- **_operatorApprovals**：类型 `mapping(address => mapping(address => bool))`  
  这是一个嵌套映射，从所有者地址到操作者地址，再到布尔值（true/false）。 
  解释：存储批量批准，即所有者批准某个操作者管理其所有 NFT。用于如市场平台批量操作。如果设置为 true，则操作者可以转移所有者的任意 NFT。

- **_tokenURIs**（可选，在 IERC721Metadata 中）：类型 `mapping(uint256 => string)`  
  解释：存储每个 tokenId 的元数据 URI（通常是 JSON 文件链接），用于描述 NFT 的属性（如图像、名称）。这不是核心接口的一部分，但常见于扩展。

- **totalSupply**（可选，在 IERC721Enumerable 中）：类型 `uint256`  
  解释：总 NFT 数量计数器。用于枚举所有 NFT。

其他变量如 _name、_symbol（字符串）用于合约元数据（名称和符号）。

#### 2. 核心函数（IERC721 接口）
ERC721 接口定义了以下函数。每个函数包括：签名、参数、返回值、解释、事件触发和潜在错误。

- **balanceOf(address owner)**：  
  参数：owner（地址）。  
  返回值：uint256（余额）。  
  解释：查询指定地址拥有的 NFT 数量。必须检查 owner 不是零地址，否则抛出错误。  
  事件：无。  
  错误：如果 owner 是零地址，抛出 "Balance query for the zero address"。  
  用法：如检查用户钱包中有多少 NFT。

- **ownerOf(uint256 tokenId)**：  
  参数：tokenId（代币 ID）。  
  返回值：address（所有者）。  
  解释：查询指定 tokenId 的所有者。如果 tokenId 不存在或已被销毁，返回零地址或抛出错误。  
  事件：无。  
  错误：如果 tokenId 不存在，抛出 "Owner query for nonexistent token"。  
  用法：验证 NFT 归属。

- **approve(address to, uint256 tokenId)**：  
  参数：to（批准给的地址），tokenId（代币 ID）。  
  返回值：无。  
  解释：批准某个地址（to）转移指定的 NFT。调用者必须是当前所有者或已批准的操作者。批准后，to 可以调用 transferFrom。批准可以覆盖之前的批准；如果 to 是零地址，则撤销批准。  
  事件：触发 Approval 事件（from: 当前所有者, to: 批准地址, tokenId）。  
  错误：如果调用者无权批准，或 tokenId 不存在。  
  用法：如在 NFT 市场上挂单，批准市场合约转移 NFT。

- **getApproved(uint256 tokenId)**：  
  参数：tokenId（代币 ID）。  
  返回值：address（批准地址）。  
  解释：查询指定 tokenId 的批准地址。如果无批准，返回零地址。  
  事件：无。  
  错误：如果 tokenId 不存在，抛出错误。  
  用法：检查是否已批准。

- **setApprovalForAll(address operator, bool approved)**：  
  参数：operator（操作者地址），approved（true/false）。  
  返回值：无。  
  解释：批量批准或撤销批准操作者管理调用者的所有 NFT。如果 approved 为 true，则 operator 可以转移调用者的任意 NFT。operator 不能是调用者自己。  
  事件：触发 ApprovalForAll 事件（owner: 调用者, operator, approved）。  
  错误：如果 operator 是调用者，抛出错误。  
  用法：如批准 OpenSea 等平台批量管理 NFT。

- **isApprovedForAll(address owner, address operator)**：  
  参数：owner（所有者），operator（操作者）。  
  返回值：bool（true/false）。  
  解释：查询 operator 是否被批准管理 owner 的所有 NFT。  
  事件：无。  
  用法：验证批量批准状态。

- **transferFrom(address from, address to, uint256 tokenId)**：  
  参数：from（发送者），to（接收者），tokenId（代币 ID）。  
  返回值：无。  
  解释：转移 NFT 从 from 到 to。调用者必须是所有者、批准地址或批量操作者。转移后，更新 _owners、_balances，清除批准。to 不能是零地址。  
  事件：触发 Transfer 事件（from, to, tokenId）。  
  错误：如果调用者无权转移、from 不是所有者、to 是零地址，或 tokenId 不存在。  
  用法：标准转移，但不检查接收者是否支持 ERC721（可能导致 NFT 丢失）。

- **safeTransferFrom(address from, address to, uint256 tokenId)**：  
  参数：from（发送者），to（接收者），tokenId（代币 ID）。  
  返回值：无。  
  解释：安全版本的 transferFrom。如果 to 是合约地址，会调用 to 的 onERC721Received 函数检查是否支持接收 NFT。如果不支持，交易回滚。  
  事件：触发 Transfer 事件。  
  错误：同 transferFrom，加上接收者不支持时回滚。  
  用法：推荐使用，防止 NFT 发送到不支持的合约。

- **safeTransferFrom(address from, address to, uint256 tokenId, bytes data)**：  
  参数：额外 data（字节数据）。  
  解释：与上同，但传递额外数据给接收者的 onERC721Received 函数。用于自定义逻辑。

其他扩展函数（非核心，但常见）：
- **supportsInterface(bytes4 interfaceId)**（从 ERC165）：检查是否支持特定接口。
- **tokenURI(uint256 tokenId)**（IERC721Metadata）：返回元数据 URI。
- **totalSupply()**、**tokenOfOwnerByIndex()** 等（IERC721Enumerable）：用于枚举 NFT。

#### 3. 事件（Events）
ERC721 定义了三个核心事件，用于日志记录和外部监听：
- **Transfer(address indexed from, address indexed to, uint256 indexed tokenId)**：NFT 转移时触发，包括铸造（from=0）和销毁（to=0）。
- **Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)**：批准单个 NFT 时触发。
- **ApprovalForAll(address indexed owner, address indexed operator, bool approved)**：批量批准时触发。

#### 4. 运行机制
ERC721 的运行基于以太坊智能合约的执行模型。以下是关键机制的步步解释：

- **铸造（Minting）机制**：  
  合约通常有自定义的 _mint 函数（非接口部分）。过程：  
  1. 检查 tokenId 不存在。  
  2. 设置 _owners[tokenId] = to（接收者）。  
  3. 增加 _balances[to] += 1。  
  4. 触发 Transfer(0, to, tokenId) 事件。  
  示例：新 NFT 创建时，从零地址“转移”到接收者。totalSupply +=1（如果有）。

- **转移（Transfer）机制**：  
  使用 transferFrom 或 safeTransferFrom。过程：  
  1. 验证调用者有权（所有者、批准或批量操作者）。  
  2. 验证 from 是当前所有者，to 非零。  
  3. 更新 _owners[tokenId] = to。  
  4. _balances[from] -=1, _balances[to] +=1。  
  5. 清除 _tokenApprovals[tokenId]（批准重置）。  
  6. 如果是 safeTransferFrom，且 to 是合约，调用 onERC721Received 检查（返回魔术值 0x150b7a02 表示支持）。  
  7. 触发 Transfer 事件。  
  安全机制：防止 NFT 丢失到不支持的合约。

- **批准（Approval）机制**：  
  approve 或 setApprovalForAll 设置权限。转移后自动清除单个批准，防止重放攻击。批量批准持久，直到手动撤销。

- **销毁（Burning）机制**：  
  自定义 _burn 函数。过程：类似转移到零地址。更新 _owners[tokenId] = 0, _balances[owner] -=1, 触发 Transfer(owner, 0, tokenId)。

- **整体安全与兼容**：  
  ERC721 支持 ERC165 接口检测。所有函数使用 require 检查以防无效操作。运行在 EVM（Ethereum Virtual Machine）上，gas 消耗取决于操作复杂度（转移约 50k gas）。兼容钱包如 MetaMask 通过事件监听更新 UI。

学习建议：阅读 OpenZeppelin 的 ERC721.sol 源码，部署测试合约在 Remix IDE 上实验。注意：ERC721A 是优化版，减少 gas，但核心接口相同。