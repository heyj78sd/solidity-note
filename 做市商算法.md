什么是自动化做市商 (AMM)？

在传统金融中，做市商（Market Maker）是专业的机构或个人，他们通过同时报出买价和卖价来为市场提供流动性。在去中心化金融（DeFi）世界里，智能合约扮演了这个角色，也就是自动化做市商（AMM）。

AMM允许用户直接与一个汇集了资金的池子（流动性池）进行交易，而不需要找到另一个交易对手。价格由一个确定性的算法（数学公式）来决定。

---

### 1. 恒定乘积做市商 (Constant Product Market Maker - CPMM)

这就是你提到的“恒积”的准确叫法。这是迄今为止最成功、最广泛应用的AMM模型，其代表就是 **Uniswap V1/V2**。

#### 核心算法

它的核心公式非常简洁优美：

$$
x \cdot y = k
$$

其中：
*   `x` 是流动性池中A代币的数量。
*   `y` 是流动性池中B代币的数量。
*   `k` 是一个常数（乘积）。

**核心思想**：在任何交易发生后（除了添加或移除流动性），池子中两种代币数量的乘积 `k` 必须保持不变。

#### 工作原理

假设一个流动性池中有 10个 ETH (`x`) 和 20,000个 DAI (`y`)。
那么 `k = 10 * 20000 = 200000`。

现在一个交易者想用 1个 ETH 来购买 DAI。
1.  **ETH进入池子**：交易者将 1个 ETH 发送到池子。池子中的ETH数量变为 `x' = 10 + 1 = 11`。
2.  **维持k不变**：为了维持 `k` 等于 200,000，池子中DAI的数量 `y'` 必须满足 `11 * y' = 200000`。
3.  **计算新的DAI数量**：`y' = 200000 / 11 ≈ 18181.82`。
4.  **支付给交易者**：交易者获得的DAI数量是池子中DAI减少的量，即 `Δy = y - y' = 20000 - 18181.82 = 1818.18` DAI。

**关键特性**：
*   **价格滑动（Slippage）**：你交易的数量越大，对价格的影响就越大。在上面的例子中，第一个ETH“买到”了1818.18个DAI。如果你再用1个ETH去买，池子里有11个ETH和18181.82个DAI，你只能买到更少的DAI。这个价格变动就是滑动。
*   **无限流动性**：理论上，这个公式永远不会让池子里的任何一种代币数量归零（只能无限接近于零），因此它可以为任何大小的交易提供报价（尽管价格可能会变得极差）。
*   **无常损失（Impermanent Loss）**：这是流动性提供者（LP）面临的一种风险。如果代币之间的市场价格发生剧烈变化，LP撤出流动性时，其资产的美元总价值可能会低于他们当初简单持有这两种代币的价值。

#### 代码例子

[Solidity constant-product-amm 例子](https://solidity-by-example.org/defi/constant-product-amm/)

---

### 2. 恒定总和做市商 (Constant Sum Market Maker - CSMM)

这就是你提到的“恒和”。这是一个理论上更简单的模型。

#### 核心算法

$$
x + y = k
$$

其中：
*   `x` 是A代币的数量。
*   `y` 是B代币的数量。
*   `k` 是一个常数（总和）。

**核心思想**：无论发生什么交易，池中两种资产的数量之和（或者经过加权后的和）保持不变。

#### 工作原理

假设一个池子中有 1000 USDC (`x`) 和 1000 DAI (`y`)。两者都是稳定币。
`k = 1000 + 1000 = 2000`。

一个交易者想用 100 USDC 购买 DAI。
1.  **USDC进入池子**：池子USDC变为 `x' = 1000 + 100 = 1100`。
2.  **维持k不变**：`1100 + y' = 2000`。
3.  **计算新的DAI数量**：`y' = 2000 - 1100 = 900`。
4.  **支付给交易者**：交易者获得 `Δy = y - y' = 1000 - 900 = 100` DAI。

**关键特性**：
*   **零滑动（Zero Slippage）**：交易价格恒定为1:1。无论你交易多少，一个USDC永远能换一个DAI。
*   **耗尽风险**：这既是优点也是缺点。如果外部市场的USDC/DAI价格偏离了1:1（比如变成了1:1.01），套利者会立刻用DAI买光池子里的所有USDC，或者反之。这会导致池子里的流动性被完全耗尽，只剩下一种代币。因此，CSMM模型本身对于价格会波动的资产是不可行的。

这个模型因为其致命缺陷，在现实中很少被单独使用。但它的“零滑动”思想启发了更高级的模型。

#### 代码例子

[Solidity  constant-sum-amm例子](https://solidity-by-example.org/defi/constant-sum-amm/)

---

### 3. 混合模型及演进

DeFi的发展并没有停留在上述两个基础模型，而是将它们结合起来，创造出更高效的算法。

#### Curve Finance (Stableswap)

Curve是为**稳定币**或**价值锚定资产**（如wETH和stETH）设计的，它的目标是：
*   在价格接近1:1时，实现**极低滑点**（像CSMM）。
*   在价格偏离很大时，依然能提供流动性（像CPMM）。

它使用了一个复杂的混合公式，可以看作是恒定总和与恒定乘积的结合体。当池子平衡时，其曲线非常平坦（接近 `x+y=k`），当池子极度不平衡时，曲线变得更弯曲（接近 `x*y=k`）。

#### Uniswap V3 (集中流动性)

Uniswap V3是对CPMM的革命性升级。它认识到，在`x*y=k`模型中，大部分流动性资金其实是闲置的，因为价格总是在一个相对小的范围内波动。

**核心思想**：**集中流动性 (Concentrated Liquidity)**。
*   LP不再将资金提供到 `(0, +∞)` 的整个价格曲线上。
*   LP可以选择一个**自定义的价格区间**来提供流动性，例如，只为USDC/ETH在$2000到$2500的价格区间内做市。
*   **效果**：
    *   **资本效率**：LP的资金被用在“刀刃上”，在选定区间内可以获得远高于V2的手续费收益。
    *   **更低滑点**：对于交易者来说，在活跃的交易区间内，流动性被“放大”了成百上千倍，滑点极低。
    *   **LP管理的复杂性**：LP需要更主动地管理自己的头寸，因为一旦价格移出他们的设定区间，他们的流动性就不再活跃，也无法赚取手续费。

### 总结对比

| 模型                  | 核心公式               | 优点                               | 缺点                             | 典型应用               |
| :-------------------- | :--------------------- | :--------------------------------- | :------------------------------- | :--------------------- |
| **恒定乘积 (CPMM)**   | `x * y = k`            | 算法简单、始终提供流动性、无需维护 | 价格滑点、无常损失、资本效率低   | Uniswap V2, Sushiswap  |
| **恒定总和 (CSMM)**   | `x + y = k`            | 零滑点、价格恒定                   | 容易被套利者耗尽流动性           | 理论模型，很少单独使用 |
| **Stableswap (混合)** | 复杂的混合公式         | 稳定币交易滑点极低、不易被耗尽     | 仅适用于价值锚定的资产对         | Curve Finance          |
| **集中流动性**        | `x * y = k` 在特定区间 | 资本效率极高、交易滑点低           | LP管理复杂、有范围限制的无常损失 | Uniswap V3             |

总而言之，Solidity中的做市商算法从最初优雅但效率不高的“恒定乘积”模型，逐步演化为更复杂、更具资本效率、也需要更主动管理的“集中流动性”模型，这个过程完美体现了DeFi领域的快速创新。

# 计算公式

为做市商（AMM）“存款”（添加流动性）和“取钱”（移除流动性）的计算，核心在于一个关键概念：**流动性提供者代币（LP Token）**。

当你向池子中添加流动性时，合约会根据你贡献的价值铸造给你一些LP代币，作为你的“存款凭证”。反之，当你移除流动性时，你需要销毁（burn）你的LP代币，合约会根据你销毁的LP代币占总量的比例，返还给你池中相应份额的两种资产。

下面我们分别对“恒定乘积”和“恒定总和”模型进行公式化解释。

### 符号定义

*   `x`: 池中A代币的总量 (reserve)
*   `y`: 池中B代币的总量 (reserve)
*   `Δx`: 用户存入或取出的A代币数量
*   `Δy`: 用户存入或取出的B代币数量
*   `S_total`: LP代币的总供应量
*   `s_minted`: 本次存款（添加流动性）新铸造的LP代币数量
*   `s_burned`: 本次取钱（移除流动性）需要销毁的LP代币数量

---

### 1. 恒定乘积做市商 (CPMM, 如 Uniswap V2)

**核心原则：添加流动性时，必须保持池中两种代币的比例不变。** 即 `x / y` 必须恒定。

#### a) 存款 (添加流动性)

**场景**：用户希望向一个已有的池子中添加 `Δx` 个A代币。

##### 首次添加流动性（`totalSupply == 0`）**

- 此时 LP Token 数量直接由几何平均数决定：

  
  $$
  shares=\sqrt{dx*dy}
  $$
  

- 为什么用几何平均？

  - 初始流动性价值可视为两种代币数量的几何平均（与 CPMM 的 *k*=*x*⋅*y* 一致）。

1.  **计算需要同步存入的B代币数量 `Δy`**
    为了维持比例，必须满足 `Δx / Δy = x / y`。因此，需要存入的B代币数量为：
    $$
    \Delta y = \frac{\Delta x \cdot y}{x}
    $$
    或者，如果用户决定要存入 `Δy`，那么需要存入的A代币数量为 `Δx = (Δy * x) / y`。用户必须同时提供这两种代币。

2.  **计算用户获得的LP代币数量 `s_minted`**
    新铸造的LP代币数量，应该与用户贡献的流动性占池子总流动性的比例相同。
    $$
    \frac{s_{minted}}{S_{total}} = \frac{\Delta x}{x} \quad \text{(或者等价地} \frac{\Delta y}{y} \text{)}
    $$
    因此，用户获得的LP代币数量为：
    $$
    s_{minted} = S_{total} \cdot \frac{\Delta x}{x}
    $$

**特殊情况：第一个流动性提供者**
当池子是空的时候 (`x=0, y=0`)，第一个LP可以自由设定初始的 `x` 和 `y` 比例。他获得的LP代币数量 `s_minted` 通常被设定为一个与存入量相关的初始值，在Uniswap V2中，这个值是 `sqrt(Δx * Δy)`。

**示例**：
*   池子状态: `x = 10` ETH, `y = 20,000` DAI, `S_total = 1000` LP tokens。
*   用户想存入 `Δx = 1` ETH。
*   **计算需存入的DAI**: `Δy = (1 * 20000) / 10 = 2000` DAI。
*   用户必须同时存入 1 ETH 和 2000 DAI。
*   **计算获得的LP代币**: `s_minted = 1000 * (1 / 10) = 100` LP tokens。
*   **新池子状态**: `x = 11` ETH, `y = 22,000` DAI, `S_total = 1100` LP tokens。

#### b) 取钱 (移除流动性)

**场景**：用户持有 `s_burned` 数量的LP代币，希望将其销毁以取回自己在池中的份额。

1.  **计算用户在池中的份额 `share`**
    $$
    \text{share} = \frac{s_{burned}}{S_{total}}
    $$

2.  **计算用户可以取回的A代币和B代币数量**
    用户可以按其份额比例，取回池中的两种资产。
    $$
    \Delta x = x \cdot \text{share} = x \cdot \frac{s_{burned}}{S_{total}}
    $$
    $$
    \Delta y = y \cdot \text{share} = y \cdot \frac{s_{burned}}{S_{total}}
    $$

**示例**：
*   池子状态: `x = 11` ETH, `y = 22,000` DAI, `S_total = 1100` LP tokens。
*   用户想销毁 `s_burned = 55` LP tokens。
*   **计算份额**: `share = 55 / 1100 = 0.05` (即 5%)。
*   **计算可取回的资产**:
    *   `Δx = 11 * 0.05 = 0.55` ETH。
    *   `Δy = 22000 * 0.05 = 1100` DAI。
*   用户销毁55个LP代币，取回0.55 ETH和1100 DAI。
*   **新池子状态**: `x = 10.45` ETH, `y = 20,900` DAI, `S_total = 1045` LP tokens。

---

### 2. 恒定总和做市商 (CSMM)

**核心原则：两种资产的（加权）总和保持不变，价格恒定为1:1（在无加权的情况下）。**

CSMM的LP代币模型没有像CPMM那样有统一标准，但我们可以基于其价值恒定的逻辑进行推导。LP代币可以被视为代表了池中资产的“总价值”。

#### a) 存款 (添加流动性)

**场景**：用户向一个稳定币池子（如USDC/DAI）中添加流动性。

1.  **计算存入的总价值**
    由于价格是1:1，存入的总价值就是两种代币数量之和。
    $$
    \text{Value}_{added} = \Delta x + \Delta y
    $$

2.  **计算用户获得的LP代币数量 `s_minted`**
    LP代币的铸造与存入的价值成正比。一个简单的模型是，LP代币的总量等于池中资产的总量。
    $$
    \frac{s_{minted}}{S_{total}} = \frac{\text{Value}_{added}}{x + y}
    $$
    因此：
    $$
    s_{minted} = S_{total} \cdot \frac{\Delta x + \Delta y}{x + y}
    $$
    或者更简单地，如果1个LP代币锚定1单位价值（例如1美元），那么 `s_minted = Δx + Δy`。

**示例**：
*   池子状态: `x = 1000` USDC, `y = 1000` DAI, `S_total = 2000` LP tokens。
*   用户存入 `Δx = 50` USDC 和 `Δy = 150` DAI。
*   **计算获得的LP代币**: `s_minted = 2000 * ((50 + 150) / (1000 + 1000)) = 2000 * (200 / 2000) = 200` LP tokens。
*   **新池子状态**: `x = 1050` USDC, `y = 1150` DAI, `S_total = 2200` LP tokens。

#### b) 取钱 (移除流动性)

**场景**：用户持有 `s_burned` 数量的LP代币，希望取回资产。

1.  **计算用户在池中的份额 `share`**
    $$
    \text{share} = \frac{s_{burned}}{S_{total}}
    $$

2.  **计算用户可以取回的A代币和B代币数量**
    用户同样按比例取回池中的两种资产。
    $$
    \Delta x = x \cdot \text{share} = x \cdot \frac{s_{burned}}{S_{total}}
    $$
    $$
    \Delta y = y \cdot \text{share} = y \cdot \frac{s_{burned}}{S_{total}}
    $$
    **重要**：由于交易可能导致池中两种资产的比例发生变化（例如，有人用大量USDC换走了DAI），所以用户取回的资产比例**不一定**等于他当初存入的比例。

**示例**：
*   假设经过一些交易后，池子状态变为: `x = 500` USDC, `y = 1700` DAI, `S_total = 2200` LP tokens。
*   之前存入200 LP代币的用户现在想全部取出。`s_burned = 200`。
*   **计算份额**: `share = 200 / 2200 ≈ 0.0909` (即 9.09%)。
*   **计算可取回的资产**:
    *   `Δx = 500 * 0.0909 ≈ 45.45` USDC。
    *   `Δy = 1700 * 0.0909 ≈ 154.55` DAI。
*   用户销毁200个LP代币，取回约45.45 USDC和154.55 DAI，总价值仍为200。

### 总结公式

| 模型         | 操作     | 核心原则            | 计算公式                                                     |
| :----------- | :------- | :------------------ | :----------------------------------------------------------- |
| **恒定乘积** | **存款** | 保持 `x/y` 比例不变 | `Δy = (Δx*y)/x` <br> `s_minted = S_total * (Δx/x)`           |
| (CPMM)       | **取钱** | 按LP代币份额取回    | `Δx = x * (s_burned/S_total)` <br> `Δy = y * (s_burned/S_total)` |
| **恒定总和** | **存款** | 按存入价值铸造LP    | `s_minted = S_total * ( (Δx+Δy)/(x+y) )`                     |
| (CSMM)       | **取钱** | 按LP代币份额取回    | `Δx = x * (s_burned/S_total)` <br> `Δy = y * (s_burned/S_total)` |